package sort

// InsertionSort 插入排序
func InsertionSort(s []int) {
	n := len(s) // c0*1
	if n <= 1 { // c1*1
		return // c2*0或1
	}
	for i := 1; i < n; i++ { // c3*n
		key := s[i]                       // c4*(n-1)
		j := i - 1                        // c5*(n-1)
		for ; j >= 0 && s[j] > key; j-- { // c6*(t(0)+t(1)...+t(n-2))
			s[j+1] = s[j] // c7*(t(0)+t(1)...+t(n-2)-(n-1))
		}
		s[j+1] = key // c8*(n-1)
	}
}

/*
使用循环不变式证明算法正确性:
* 初始化:
> 循环在第一次迭代之前,它为真
初始化时i=1, 也就是子数组s[0:i]为s[0:1], 也就是一个元素组成, 显然此时s[0:1]是排好序的, 此时循环不变式成立;
* 保持:
> 如果循环在某次迭代之前它为真, 那么下次迭代之前它仍为真
InsertionSort算法的第二层for循环做的是将临时s[i]的值赋值给一个临时变量key, 然后比较s[i-1], s[i-2]...s[i-n]与key的大小,直到i-n=0或者s[i-n]不比key大,
此时再把key赋值给i-n+1, 这样就保证了在外层的一次迭代完成后, 也就是下一次迭代开始前s[0,i]依然是有序的, 并且依然有原来的s[0,i]中的元素组成.
依然保持循环不变式.
* 终止:
在第一层for循环终止时, i=len(s)-1,因为已经证明在下一次迭代开始前循环不变式为真, 所以此时s[0:len(s)]是有序的, 并且是由原本s[0:len(s)]的元素组成的.
最终证明此插入排序的正确性
*/

/*
算法分析:
假设每一行的运行时间为常量时间ci,
所以总时间可以用如下公式表示:
T(n) = c0+c1+c2+c3*n+c4*(n-1)+c5*(n-1)+c6*(t(0)+t(1)...+t(n-2))+c7*(t(0)+t(1)...+t(n-2)-(n-1))+c8*(n-1)
这样对于确定输入规模的数据, 最好的情况是, 数据集合已经是拍好序的, 这样就有
T(n) = c0+c1+c2+c3*n+c4*(n-1)+c5*(n-1)+c6*(1)+c7*(0)+c8*(n-1)
	 = (c3+c4+c5+c8)*n + (c0+c1+c2-c4-c5+c6-c8)
	 = a*n + b
这样对于最坏情况就是数据的数据集合是倒序排序的, 这样就有:
T(n) = c0+c1+c2+c3*n+c4*(n-1)+c5*(n-1)+c8*(n-1)+c6*(2+3+...+n-1)+c7*(1+2+3+...+n-2)
	 = c6*(n+1)*(n-1)/2 + c7*(n-1)*(n-2)/2 + c0+c1+c2+c3*n+c4*(n-1)+c5*(n-1)+c8*(n-1)
	 = (c6/2)*(n^2-1) + (c7/2)*(n^2-3*n+2) + c0+c1+c2+c3*n+c4*(n-1)+c5*(n-1)+c8*(n-1)
	 = ((c6+c7)/2)*n^2 - c6/2 - (3*c7/2)*n + c7 + c0+c1+c2+c3*n+c4*(n-1)+c5*(n-1)+c8*(n-1)
	 = ((c6+c7)/2)*n^2 + (c3+c4+c5+c8-3*c7/2)*n + (c0+c1+c2-c4-c5+c7-c8)
	 = a*n^2 + b*n + c

增长量级:
这样最坏情况的增长量级就是 `n^2` , 用符号表示是ø(n^2)
*/
