package sort

// InsertionSort 插入排序
func InsertionSort(s []int) {
	n := len(s)
	if n <= 1 {
		return
	}
	for i := 1; i < n; i++ {
		key := s[i]
		j := i - 1
		for ; j >= 0 && s[j] > key; j-- {
			s[j+1] = s[j]
		}
		s[j+1] = key
	}
}

/*
使用循环不变式证明算法正确性:
* 初始化:
> 循环在第一次迭代之前,它为真
初始化时i=1, 也就是子数组s[0:i]为s[0:1], 也就是一个元素组成, 显然此时s[0:1]是排好序的, 此时循环不变式成立;
* 保持:
> 如果循环在某次迭代之前它为真, 那么下次迭代之前它仍为真
InsertionSort算法的第二层for循环做的是将临时s[i]的值赋值给一个临时变量key, 然后比较s[i-1], s[i-2]...s[i-n]与key的大小,直到i-n=0或者s[i-n]不比key大,
此时再把key赋值给i-n+1, 这样就保证了在外层的一次迭代完成后, 也就是下一次迭代开始前s[0,i]依然是有序的, 并且依然有原来的s[0,i]中的元素组成.
依然保持循环不变式.
* 终止:
在第一层for循环终止时, i=len(s)-1,因为已经证明在下一次迭代开始前循环不变式为真, 所以此时s[0:len(s)]是有序的, 并且是由原本s[0:len(s)]的元素组成的.
最终证明此插入排序的正确性
*/
